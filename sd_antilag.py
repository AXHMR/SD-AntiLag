#!/usr/bin/env python3
import os
import sys
import time
import threading
import subprocess
from dataclasses import dataclass
from typing import Optional

from PyQt6.QtWidgets import (
    QApplication, QMainWindow, QWidget,
    QVBoxLayout, QHBoxLayout,
    QLabel, QPushButton, QComboBox,
    QCheckBox, QMessageBox, QLineEdit
)
from PyQt6.QtCore import Qt, QTimer, QSettings
from PyQt6.QtGui import QIcon

# If you're using PyQt5 instead of PyQt6, change the imports above to:
# from PyQt5.QtWidgets import *
# from PyQt5.QtCore import Qt, QTimer, QSettings
# from PyQt5.QtGui import QIcon

SERVICE_NAME = "sd-antilag.service"
KEEPALIVE_SCRIPT_PATH = os.path.expanduser("~/.local/bin/sd_antilag_keepalive.sh")
SYSTEMD_USER_DIR = os.path.expanduser("~/.config/systemd/user")
SERVICE_PATH = os.path.join(SYSTEMD_USER_DIR, SERVICE_NAME)

# Default filename (user can override in the UI)
DEFAULT_FILENAME = "SD-AntiLag_File"


@dataclass
class Config:
    mount_point: str
    interval: int
    filename: str


def resource_path(relative_path: str) -> str:
    """
    Get absolute path to resource, works for dev and for PyInstaller.
    """
    if hasattr(sys, "_MEIPASS"):
        base_path = getattr(sys, "_MEIPASS")
    else:
        base_path = os.path.dirname(os.path.abspath(__file__))
    return os.path.join(base_path, relative_path)


class KeepAliveThread(threading.Thread):
    def __init__(self, config: Config):
        super().__init__(daemon=True)
        self.config = config
        self._running = threading.Event()
        self._running.set()

    def stop(self):
        self._running.clear()

    def run(self):
        mount = self.config.mount_point
        interval = self.config.interval
        filename = self.config.filename
        keepalive_file = os.path.join(mount, filename)

        while self._running.is_set():
            if os.path.isdir(mount):
                try:
                    with open(keepalive_file, "w") as f:
                        f.write(".")
                except Exception as e:
                    print(f"[SD-AntiLag] Failed to write keepalive file: {e}", file=sys.stderr)
            else:
                print(f"[SD-AntiLag] Mount point not found: {mount}", file=sys.stderr)

            # Sleep in small chunks so stop() responds quickly
            for _ in range(interval * 10):
                if not self._running.is_set():
                    break
                time.sleep(0.1)


def find_sd_mounts():
    """
    Try to detect SD card mount points on Steam Deck / Linux.
    Common places:
      - /run/media/$USER/*
      - /run/media/*
      - /mnt/*
    """
    user = os.environ.get("USER", "deck")
    candidates = []

    bases = [
        f"/run/media/{user}",
        "/run/media",
        "/mnt",
    ]

    for base in bases:
        if not os.path.isdir(base):
            continue
        try:
            for name in os.listdir(base):
                path = os.path.join(base, name)
                if os.path.ismount(path):
                    candidates.append(path)
        except PermissionError:
            continue

    # Deduplicate and sort
    return sorted(set(candidates))


def run_cmd(cmd):
    """
    Run a system command with a *cleaned* environment so that PyInstaller's
    bundled libraries (e.g. libcrypto.so) don't break system tools like systemctl.
    """
    env = os.environ.copy()
    for key in ("LD_LIBRARY_PATH", "PYTHONHOME", "PYTHONPATH"):
        env.pop(key, None)
    return subprocess.run(cmd, text=True, capture_output=True, env=env)


def systemd_is_active():
    """
    Check if the background service is running.
    """
    result = run_cmd(["systemctl", "--user", "is-active", SERVICE_NAME])
    return result.returncode == 0 and result.stdout.strip() == "active"


def systemd_enable_and_start():
    run_cmd(["systemctl", "--user", "daemon-reload"])
    run_cmd(["systemctl", "--user", "enable", "--now", SERVICE_NAME])


def systemd_restart():
    """
    Restart an already-enabled user service.
    """
    run_cmd(["systemctl", "--user", "daemon-reload"])
    run_cmd(["systemctl", "--user", "restart", SERVICE_NAME])


def systemd_stop_and_disable():
    run_cmd(["systemctl", "--user", "stop", SERVICE_NAME])
    run_cmd(["systemctl", "--user", "disable", SERVICE_NAME])
    run_cmd(["systemctl", "--user", "daemon-reload"])


def write_keepalive_script(config: Config):
    os.makedirs(os.path.dirname(KEEPALIVE_SCRIPT_PATH), exist_ok=True)

    script = f"""#!/bin/bash
# Auto-generated by SD-AntiLag
CARD_MOUNT="{config.mount_point}"
INTERVAL_SECONDS="{config.interval}"
KEEPALIVE_FILE="$CARD_MOUNT/{config.filename}"

echo "[SD-AntiLag] Starting keepalive on $CARD_MOUNT (interval: $INTERVAL_SECONDS s, file: $KEEPALIVE_FILE)" >&2

while true; do
    if [ -d "$CARD_MOUNT" ]; then
        printf . > "$KEEPALIVE_FILE" 2>/dev/null || echo "[SD-AntiLag] Failed to write keepalive file" >&2
    else:
        echo "[SD-AntiLag] Mount point not found: $CARD_MOUNT" >&2
    fi
    sleep "$INTERVAL_SECONDS"
done
"""
    with open(KEEPALIVE_SCRIPT_PATH, "w", encoding="utf-8") as f:
        f.write(script)
    os.chmod(KEEPALIVE_SCRIPT_PATH, 0o755)


def write_systemd_service():
    os.makedirs(SYSTEMD_USER_DIR, exist_ok=True)
    unit = f"""[Unit]
Description=SD-AntiLag SD card keep-alive
After=default.target

[Service]
Type=simple
ExecStart=%h/.local/bin/sd_antilag_keepalive.sh
Restart=always
RestartSec=3

[Install]
WantedBy=default.target
"""
    with open(SERVICE_PATH, "w", encoding="utf-8") as f:
        f.write(unit)


class MainWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("SD-AntiLag")

        # Settings for persistence
        self.settings = QSettings("SD-AntiLag", "SD-AntiLag")

        # Set window icon from bundled SVG (if present)
        icon_path = resource_path("sd-antilag.svg")
        if os.path.exists(icon_path):
            self.setWindowIcon(QIcon(icon_path))

        self.keepalive_thread: Optional[KeepAliveThread] = None
        self.mounts = find_sd_mounts()

        self._build_ui()
        self._load_settings()
        self._refresh_status()

        # Poll background service status every 2 seconds
        self.status_timer = QTimer(self)
        self.status_timer.timeout.connect(self._refresh_status)
        self.status_timer.start(2000)

    def _build_ui(self):
        main_widget = QWidget()
        layout = QVBoxLayout()
        layout.setSpacing(10)

        title = QLabel("SD-AntiLag")
        title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        font = title.font()
        font.setPointSize(18)
        font.setBold(True)
        title.setFont(font)

        layout.addWidget(title)

        # SD card mount selection
        mount_row = QHBoxLayout()
        mount_label = QLabel("SD Card Location:")
        self.mount_combo = QComboBox()
        if self.mounts:
            self.mount_combo.addItems(self.mounts)
        else:
            self.mount_combo.addItem("No mounts detected – select manually")
        mount_row.addWidget(mount_label)
        mount_row.addWidget(self.mount_combo)
        layout.addLayout(mount_row)

        # Interval selection: 1–10 seconds, 3 seconds (recommended) as default
        interval_row = QHBoxLayout()
        interval_label = QLabel("Write interval:")
        self.interval_combo = QComboBox()
        for secs in range(1, 11):
            if secs == 3:
                text = "3 seconds (recommended)"
            else:
                text = f"{secs} seconds"
            self.interval_combo.addItem(text, userData=secs)
        # default UI index (will be overridden by saved settings if present)
        self.interval_combo.setCurrentIndex(2)
        self.interval_combo.currentIndexChanged.connect(self._interval_changed)
        interval_row.addWidget(interval_label)
        interval_row.addWidget(self.interval_combo)
        layout.addLayout(interval_row)

        # Keepalive filename input
        file_row = QHBoxLayout()
        file_label = QLabel("Keepalive file name:")
        self.filename_input = QLineEdit()
        self.filename_input.setPlaceholderText(DEFAULT_FILENAME)
        self.filename_input.textChanged.connect(self._filename_changed)
        file_row.addWidget(file_label)
        file_row.addWidget(self.filename_input)
        layout.addLayout(file_row)

        # Background checkbox
        self.background_checkbox = QCheckBox(
            "Run in background (service persists across reboots)"
        )
        # Live reaction when user toggles this
        self.background_checkbox.stateChanged.connect(self._background_mode_changed)
        layout.addWidget(self.background_checkbox)

        # Start/Stop button
        self.toggle_button = QPushButton("Start")
        self.toggle_button.clicked.connect(self._toggle)
        layout.addWidget(self.toggle_button)

        # Status label at bottom
        self.status_label = QLabel("Status: Stopped")
        self.status_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        layout.addWidget(self.status_label)

        main_widget.setLayout(layout)
        self.setCentralWidget(main_widget)

        # Make the window non-resizable
        self.setFixedSize(520, 280)

    # --- Settings persistence helpers ---

    def _load_settings(self):
        # Interval
        last_interval = self.settings.value("interval_seconds", 3, type=int)
        index = 2  # fallback to 3 (recommended)
        for i in range(self.interval_combo.count()):
            if self.interval_combo.itemData(i) == last_interval:
                index = i
                break
        self.interval_combo.blockSignals(True)
        self.interval_combo.setCurrentIndex(index)
        self.interval_combo.blockSignals(False)

        # Filename
        last_filename = self.settings.value("filename", "", type=str)
        if last_filename:
            self.filename_input.blockSignals(True)
            self.filename_input.setText(last_filename)
            self.filename_input.blockSignals(False)

        # Background preference (only used when nothing is running)
        last_bg = self.settings.value("background_mode", False, type=bool)
        self.background_checkbox.blockSignals(True)
        self.background_checkbox.setChecked(bool(last_bg))
        self.background_checkbox.blockSignals(False)

    def _save_settings(self):
        self.settings.setValue("interval_seconds", self._current_interval())
        self.settings.setValue("filename", self._current_filename())
        self.settings.setValue("background_mode", self.background_checkbox.isChecked())

    # --- Config access ---

    def _current_mount(self) -> str:
        return self.mount_combo.currentText().strip()

    def _current_interval(self) -> int:
        secs = self.interval_combo.currentData()
        if secs is None:
            text = self.interval_combo.currentText().split()[0]
            try:
                secs = int(text)
            except ValueError:
                secs = 3
        return secs

    def _current_filename(self) -> str:
        name = self.filename_input.text().strip()
        if not name:
            return DEFAULT_FILENAME
        # Ensure it's a simple file name (no slashes)
        return name.replace("/", "_")

    def _current_config(self) -> Config:
        return Config(
            mount_point=self._current_mount(),
            interval=self._current_interval(),
            filename=self._current_filename(),
        )

    # --- UI event handlers ---

    def _toggle(self):
        # Start/Stop button
        if self.keepalive_thread is not None or systemd_is_active():
            self._stop_all()
        else:
            self._start()

    def _start(self):
        cfg = self._current_config()

        if not os.path.isdir(cfg.mount_point):
            reply = QMessageBox.question(
                self,
                "Mount point not found",
                f"The selected path does not look like a mounted SD card:\n\n"
                f"{cfg.mount_point}\n\n"
                f"Start anyway?",
                QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No,
            )
            if reply != QMessageBox.StandardButton.Yes:
                return

        if self.background_checkbox.isChecked():
            # Background mode: create script + service, enable + start
            try:
                write_keepalive_script(cfg)
                write_systemd_service()
                systemd_enable_and_start()
            except Exception as e:
                QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to start background service:\n{e}",
                )
                return
        else:
            # Foreground mode: start thread in this process
            self.keepalive_thread = KeepAliveThread(cfg)
            self.keepalive_thread.start()

        self._save_settings()
        self._refresh_status()

    def _stop_all(self):
        # Stop foreground thread if running
        if self.keepalive_thread is not None:
            self.keepalive_thread.stop()
            self.keepalive_thread = None

        # Stop + disable background service if it exists
        try:
            if systemd_is_active():
                systemd_stop_and_disable()
        except Exception:
            pass

        self._refresh_status()

    def _background_mode_changed(self, state: int):
        """
        Called when the checkbox is toggled WHILE the app is open.
        If something is running, switch mode automatically and restart it
        with the current config. If not running, just save preference.
        """
        fg_running = self.keepalive_thread is not None
        try:
            bg_running = systemd_is_active()
        except Exception:
            bg_running = False

        # stateChanged(int) gives 0 (unchecked), 2 (checked) – treat non-zero as checked
        want_background = bool(state)

        # If nothing is running, just save preference and let it affect next Start()
        if not fg_running and not bg_running:
            self._save_settings()
            # Don't touch checkbox state here; user just changed it.
            self._refresh_status()
            return

        cfg = self._current_config()

        if want_background:
            # We want background mode now
            if bg_running:
                # Already background, nothing to do
                self._save_settings()
                return

            # Convert foreground -> background
            if fg_running and self.keepalive_thread is not None:
                self.keepalive_thread.stop()
                self.keepalive_thread = None
            try:
                write_keepalive_script(cfg)
                write_systemd_service()
                systemd_enable_and_start()
            except Exception as e:
                QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to switch to background mode:\n{e}",
                )
                # Roll back checkbox if switch failed
                self.background_checkbox.blockSignals(True)
                self.background_checkbox.setChecked(False)
                self.background_checkbox.blockSignals(False)

        else:
            # We want foreground mode now
            if fg_running:
                # Already foreground, nothing to do
                self._save_settings()
                return

            # Convert background -> foreground
            if bg_running:
                try:
                    systemd_stop_and_disable()
                except Exception as e:
                    QMessageBox.critical(
                        self,
                        "Error",
                        f"Failed to stop background service:\n{e}",
                    )
                    # Roll back checkbox if switch failed
                    self.background_checkbox.blockSignals(True)
                    self.background_checkbox.setChecked(True)
                    self.background_checkbox.blockSignals(False)
                    self._refresh_status()
                    return

            # Start foreground thread with current config
            self.keepalive_thread = KeepAliveThread(cfg)
            self.keepalive_thread.start()

        self._save_settings()
        self._refresh_status()

    def _interval_changed(self, index: int):
        """
        Called when the interval dropdown changes.
        If something is running, restart it with the new interval.
        Also persist the new interval.
        """
        self._save_settings()

        fg_running = self.keepalive_thread is not None
        try:
            bg_running = systemd_is_active()
        except Exception:
            bg_running = False

        if not fg_running and not bg_running:
            # Nothing running – just persist the choice
            self._refresh_status()
            return

        cfg = self._current_config()

        if fg_running:
            # Restart foreground thread with new interval
            if self.keepalive_thread is not None:
                self.keepalive_thread.stop()
            self.keepalive_thread = KeepAliveThread(cfg)
            self.keepalive_thread.start()
        elif bg_running:
            # Rewrite script and restart background service with new interval
            try:
                write_keepalive_script(cfg)
                systemd_restart()
            except Exception as e:
                QMessageBox.critical(
                    self,
                    "Error",
                    f"Failed to apply new interval to background service:\n{e}",
                )

        self._refresh_status()

    def _filename_changed(self, _text: str):
        """
        Persist filename changes immediately.
        """
        self._save_settings()

    # --- Qt events / status updates ---

    def closeEvent(self, event):
        # If not in background mode, stop thread on window close.
        if not self.background_checkbox.isChecked():
            if self.keepalive_thread is not None:
                self.keepalive_thread.stop()
                self.keepalive_thread = None
        # Don't touch the systemd service here – user must hit Stop
        # or use the checkbox to switch modes explicitly.
        event.accept()

    def _refresh_status(self):
        fg_running = self.keepalive_thread is not None
        try:
            bg_running = systemd_is_active()
        except Exception:
            bg_running = False

        # Only force checkbox state when something is actually running.
        # If nothing is running, leave the checkbox as the user set it.
        if fg_running or bg_running:
            self.background_checkbox.blockSignals(True)
            self.background_checkbox.setChecked(bg_running)
            self.background_checkbox.blockSignals(False)

        if fg_running:
            self.status_label.setText("Status: Running (foreground)")
            self.toggle_button.setText("Stop")
        elif bg_running:
            self.status_label.setText("Status: Running (background service)")
            self.toggle_button.setText("Stop")
        else:
            self.status_label.setText("Status: Stopped")
            self.toggle_button.setText("Start")


def main():
    app = QApplication(sys.argv)
    win = MainWindow()
    win.show()
    sys.exit(app.exec())


if __name__ == "__main__":
    main()
